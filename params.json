{
  "name": "Ros-type-introspection",
  "tagline": "Introspection at runtime of unknown data types in ROS (Robotic Operative System)",
  "body": "#Ros message introspection\r\n### Or... \"If you don't know why you need it, probably you don't need it\".\r\n\r\nThis simple library extracts information from a ROS message/type\r\nunknown at compilation time. \r\n\r\nHave you ever wanted to build an app that can subscribe to __any__ \r\n`topic` and extract its content, or can read data from __any__ `rosbag`? \r\nWhat if the topic and/or the bag contains user defined ROS types ignored at compilation time?\r\n\r\nThe common solution in the ROS ecosystem is to use Python, that provides\r\nthe needed introspection. Tools, for instance, like __rqt_plot__ and __rqt_bag__ took this approach.\r\nThis library implements a __C++ alternative__.\r\n\r\nIntrospections is achieved parsing the schema stored in `ros::message_traits::Definition`\r\n\r\nOnce this schema is parsed and understood, it can be used to deserialize a raw message.\r\n\r\nIt also offer an easy way to remap/rename the data using a simple set of \r\nrules.\r\n\r\n#Background\r\n### Or... \"Repeating something you know already\"\r\nThe ROS Message Types (I will refer to them as \"ROS types\" further) can be described as \r\na [Interface Describtion Language](https://en.wikipedia.org/wiki/Interface_description_language).\r\nThis approach is very well known and commonly used on the web and in distributed systems in general.\r\n\r\nA [rosmsg](http://wiki.ros.org/rosmsg) is defined by the user; an \"IDL compiler\", i.e. \r\n[gencpp](http://wiki.ros.org/gencpp), \r\nreads this schema and generates an header file that contains the code that shall be included\r\nin the applications, both on the publisher *and* subscriber sides.\r\n\r\nThis approach creates strong and type-safe contracts between the producer and the consumer \r\nof the message and, additionally, is needed to implements a fast \r\nserialization / deserialization mechanism.\r\n\r\nThe only \"limitation\", at least in C++, is the fact that the generated header files \r\nmust be included in the source code.\r\n\r\n#The parser\r\n### Or...\"Thank you gencpp for storing everything I need to build introspection\"\r\nIn most cases we have access to the Ros Message Type Definition.\r\nLuckily for us this string contains __all__ the information we need to know how to deserialize \r\nthe ROS message.\r\nThe goal of the [parser](ros-type-introspection/blob/master/include/ros_type_introspection/parser.hpp)\r\nis to extract the schema and made it available to the user and the deserializer.\r\n\r\nThis can be simply done calling the function:\r\n\r\n```c++\r\n  ROSTypeList buildROSTypeMapFromDefinition( const std::string& type_name,\r\n                                             const std::string& msg_definition );\r\n```\r\n###Example 1\r\n\r\nFurther we try to parse the type(s) contained in\r\n[geometry_msgs::Pose](http://docs.ros.org/kinetic/api/geometry_msgs/html/msg/Pose.html)\r\n\r\n```c++\r\n  #include <geometry_msgs/Pose.h>\r\n  // NOTE: in this trivial example we need to include geometry_msgs/Pose\r\n  // even if the main goal of this library is to avoid that.\r\n  \r\n  ///...\r\n  \r\n  using namespace RosIntrospection;\r\n  ROSTypeList typelist = buildROSTypeMapFromDefinition(\r\n                ros::message_traits::DataType< geometry_msgs::Pose >::value(),\r\n                ros::message_traits::Definition< geometry_msgs::Pose >::value());\r\n  std::cout << typelist << std::endl;             \r\n```\r\nThe expected output is:\r\n\r\n```\r\n   geometry_msgs/Pose : \r\n      position : geometry_msgs/Point\r\n      orientation : geometry_msgs/Quaternion\r\n\r\n   geometry_msgs/Point : \r\n      x : float64\r\n      y : float64\r\n      z : float64\r\n\r\n   geometry_msgs/Quaternion : \r\n      x : float64\r\n      y : float64\r\n      z : float64\r\n      w : float64\r\n```\r\n\r\nAs expected each message type has a set of fields with a fieldname and a typename.\r\n\r\nWhat is noteworthy is that also all of the non-built-in type in the hierarchy \r\nare parsed as well, specifically `geometry_msgs/Point` and `geometry_msgs/Quaternion`.\r\n\r\n###Example 2\r\n\r\nIn the next example we will parse all the types found in a single ROS bag.\r\nWe will __not__ need to __`#include`__ any of those ROS Types. \r\n\r\nTo understand this chunk of code you must\r\nbe familiar with the [rosbag::Bag API](http://wiki.ros.org/rosbag/Code%20API)\r\n\r\n```c++\r\n  rosbag::Bag bag;\r\n  bag.open( file_name, rosbag::bagmode::Read );\r\n\r\n  rosbag::View bag_view ( bag, ros::TIME_MIN, ros::TIME_MAX, true );\r\n  auto first_time = bag_view.getBeginTime();\r\n\r\n  const auto& connections = bag_view.getConnections();\r\n\r\n  // create a list and a type map for each topic\r\n  std::map<std::string, RosIntrospection::ROSTypeList> type_map;\r\n\r\n  for(unsigned i=0; i<connections.size(); i++)\r\n  {\r\n     auto topic_map = buildROSTypeMapFromDefinition( connections[i]->datatype,\r\n                                                     connections[i]->msg_def);\r\n                                                     \r\n     type_map.insert( std::make_pair(connections[i]->topic, topic_map));\r\n  }\r\n```\r\n\r\n# The deserializer\r\n### Or... \"Reverse engineering of boost::serialization + inefficient data structures\"\r\n\r\nThe next thing to understand is the \r\n[deserializer](ros-type-introspection/blob/master/include/ros_type_introspection/deserializer.hpp).\r\nOnce the schema is available in the form of a 'RosIntrospection::ROSTypeList` we are\r\nable to take a raw message and extract valuable information from that.\r\n\r\nWe don't have the support of the C++ typesystem, which was provided by the \r\nincluded file generated by the IDL compiler, therefore the fields of the message can not be\r\n\"composed\" into a `struct` or `class`.\r\n\r\nThe only data structure that can contain our data is currently a flat structure that store\r\nsimple key-value pairs:\r\n\r\n```c++\r\n  // note; LongString is just a string with improved small object optimization.\r\n  typedef struct{\r\n    std::vector< std::pair<LongString, double> > value;\r\n    std::vector< std::pair<LongString, LongString> > name_id;\r\n  }ROSTypeFlat;\r\n```\r\n\r\nThis highlights already some of the main limitations of the parser:\r\n\r\n* It is not well suited for objects with large arrays, like images, maps point clouds.\r\nFrom a very selfish point of view, I am not optimizing this use case because I don't need it.\r\nVery large arrays are simply discarted. \r\n\r\n* A double is used as a \"conservative\" type to store any integral. This, together with the LongString class\r\nmakes the code simpler but inefficient from the point of view of memory.\r\n\r\n* LongString run faster than std:string in many cases, because it use stack allocation instead of heap allocation.\r\nUnfortunately, as a result more RAM is needed. Nevertheless it is easy to change this with compilation flags.\r\n\r\n### Example 3 \r\n \r\nLet's see how parser and deserializer work together with a slightly more complex type, \r\n[sensor_msgs::JointState](http://docs.ros.org/api/sensor_msgs/html/msg/JointState.html). \r\n\r\nLet's suppose that a publisher sends this instance of __sensor_msgs::JointState__ using a ROS topic\r\n(the code related to ROS and publishing is ignored here):\r\n\r\n```c++\r\n    sensor_msgs::JointState joint_state;\r\n\r\n    joint_state.header.seq = 2016;\r\n    joint_state.header.stamp.sec  = 1234;\r\n    joint_state.header.stamp.nsec = 567*1000*1000;\r\n    joint_state.header.frame_id = \"pippo\";\r\n\r\n    joint_state.name.resize( 3 );\r\n    joint_state.position.resize( 3 );\r\n    joint_state.velocity.resize( 3 );\r\n    joint_state.effort.resize( 3 );\r\n\r\n    std::string names[3];\r\n    names[0] = (\"hola\");\r\n    names[1] = (\"ciao\");\r\n    names[2] = (\"bye\");\r\n\r\n    for (int i=0; i<3; i++)\r\n    {\r\n        joint_state.name[i] = names[i];\r\n        joint_state.position[i]= 11+i;\r\n        joint_state.velocity[i]= 21+i;\r\n        joint_state.effort[i]= 31+i;\r\n    }\r\n  \r\n  //publish this on a ros topic...\r\n```\r\n\r\nOn the receiver side we want to read this data but we don't know at compilation\r\ntime that it is a `sensor_msgs::Imu`.\r\nTo solve this problem we need the support of an usefull but not well know class:\r\n[topic_tools::ShapeShifter](http://docs.ros.org/diamondback/api/topic_tools/html/classtopic__tools_1_1ShapeShifter.html)\r\n\r\n```c++\r\n//callback subscribed to the topic\r\nvoid DataStreamROS::topicCallback(const topic_tools::ShapeShifter::ConstPtr& msg)\r\n{\r\n    using namespace RosIntrospection;\r\n\r\n\t// reuse if already parsed.\r\n    static std::map<std::string, ROSTypeList> registered_types;\r\n\r\n    auto& datatype_name = msg->getDataType();\r\n\r\n\t// If not stored, parse it and store it.\r\n    if( registered_types.find( datatype_name ) == registered_types.end() )\r\n    {\r\n        registered_type[datatype_name] = buildROSTypeMapFromDefinition(\r\n\t\t\t\t\t\t\t\t\t\tdatatype_name,\r\n\t\t\t\t\t\t\t\t\t\tmsg->getMessageDefinition() );\r\n    }\r\n    // allocate a buffer and copy the raw message.\r\n    std::vector<uint8_t> buffer( msg->size() ); \r\n    ros::serialization::OStream stream(buffer, sizeof(buffer));\r\n    msg->write(stream);\r\n\r\n    // Important: use a COPY of the pointer.\r\n    uint8_t* buffer_ptr = buffer;\r\n    \r\n    LongString topicname( topic_name.data(), topic_name.length() );\r\n\r\n    ROSTypeFlat flat_container;\r\n    flat_container = buildRosFlatType( registered_type[datatype_name], \r\n                                       ROSType(datatype_name), \r\n                                       topicname, \r\n                                       &buffer_ptr);\r\n                                       \r\n    for(auto&it: flat_container.value) {\r\n        std::cout << it.first << \" >> \" << it.second << std::endl;\r\n    }\r\n    std::cout << \"----\" << std::endl;\r\n    for(auto&it: flat_container.name_id) {\r\n        std::cout << it.first << \" >> \" << it.second << std::endl;\r\n    }\r\n}\r\n```\r\n\r\nThe exepected output is:\r\n\r\n```\r\nJointState.header.seq >> 2016\r\nJointState.header.stamp >> 1234.57\r\nJointState.position[0] >> 11\r\nJointState.position[1] >> 12\r\nJointState.position[2] >> 13\r\nJointState.velocity[0] >> 21\r\nJointState.velocity[1] >> 22\r\nJointState.velocity[2] >> 23\r\nJointState.effort[0] >> 31\r\nJointState.effort[1] >> 32\r\nJointState.effort[2] >> 33\r\n----\r\nJointState.header.frame_id >> pippo\r\nJointState.name[0] >> hola\r\nJointState.name[1] >> ciao\r\nJointState.name[2] >> bye\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n \r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}